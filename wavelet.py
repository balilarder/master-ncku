# -*- coding: utf-8 -*-
"""wavelet.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19FGip-THkJVbnxofkI1Qoht5LiltfJbM
"""

# 1. input a time series, interpolate, wavelet coefficient...
import pandas as pd
import numpy as np

import matplotlib.pyplot as plt
from datetime import datetime

# read air pollution csv file

from google.colab import drive
drive.mount('/content/drive')

df = pd.read_csv("/content/drive/My Drive/master_research/dataset/beijing_17_18_aq.csv")    

stations_data = df.groupby('stationId')
# stations 為所有北京不同的station
stations = list(stations_data.groups.keys())
# for each station, generate its time series


date_rng = pd.date_range(start='1/1/2017 14:00', end='1/31/2018 15:00', freq='H')
def time_series(id, type):
    # id is a sensor, ex: aotizhongxin_aq
    # type is ex: pm25
    timestamp = list(date_rng)
    value = [np.nan]*len(timestamp)
    
    select = stations_data.get_group(id)
    select = select[['utc_time', type]]

    # fill the data:

    cur = 0
    for i in range(len(select.index)):
        
        for j in range(cur, len(timestamp)):
            
            if str(timestamp[j]) == select.iloc[i]['utc_time']:
                value[j] = select.iloc[i][type]
                cur = j

                break
            
    return value

# 1d interpolate for np.nan
import math
y = np.array([1, 1, 1, np.nan, np.nan, 2, 2, np.nan, 0])

def interpolate_linear1d(i):
    x = []
    xp = []
    fp = []
#     xp = list(range(len(i)))
    for a in range(len(i)):
        if math.isnan(i[a]):
            x.append(a)
        else:
            xp.append(a)
            fp.append(i[a])

#     print(x)
#     print(xp)
#     print(fp)
    inter = np.interp(x, xp, fp)
    
    for a, b in zip(x, inter):
        i[a] = b
        
    return i

# 使用interpolate
a = interpolate_linear1d(y)
print(a)
print(len(a))

# 以表格方式呈現所有地方time series
d = []

for s in stations:
    v = time_series(s, 'PM2.5')
    dup = list(v)
    dup = dup         # 修正要取的data片段
    print(dup)
#     for n, i in enumerate(dup):
#         if np.isnan(i):
#             dup[n] = 1
            
#         else:
#             dup[n] = 0
    
    d.append(dup)

# # time and missing data之間顏色圖
plt.imshow(d, aspect='auto')
## imshow 裡面有interpolate方式，請注意


plt.grid(b=None)
plt.show()

# linear interpolate show

d = []

for s in stations:
    v = time_series(s, 'PM2.5')
    dup = list(v)
    dup = interpolate_linear1d(dup)        

    
    d.append(dup)
plt.imshow(d, aspect='auto')
plt.grid(b=None)
plt.show()

# 可以show出timeseries
v = time_series("aotizhongxin_aq", 'PM2.5')
plt.plot(date_rng, v)
plt.show()

v = interpolate_linear1d(v)
plt.plot(date_rng, v)
plt.show()

# 有缺值的顯示

d = [[0, 1, 1, np.nan],
     [3, 0, 0, 1],
     [np.nan, np.nan, 2, 1]
    
]
# # time and missing data之間顏色圖
plt.imshow(d, aspect='auto')
## imshow 裡面有interpolate方式，請注意
plt.grid(b=None)
plt.show()

# Wavelet table
# i = [1, 1, 6, 8, 9, 11, 15]
i = time_series("dingling_aq", 'PM2.5')
def wavelet_coefficient_table(i):
    table = [['level', 'average', 'difference']]
    level = 1
    length = len(i)
    
    while(length > 1):
        if length % 2 == 0:
            length_next = int(length / 2)
        else:
            length_next = int((length+1) / 2)

        
#         print(length, length_next, level)
        
        average = ['x']*length_next
        difference = ['x']*length_next
        
        # 偶數
        if length % 2 == 0:
            for x in range(length_next):
                v1 = i[x*2]
                v2 = i[x*2 + 1]
                
#                 print('  ', v1, v2)
                average[x] = float((v1+v2) / 2)
                difference[x] = float((v1-v2) / 2)
        # 奇數
        else:
            # seperate series into 3 pieces
            m = int((length-1)/2)
            middle = i[m]
            before = i[:m]
            after = i[m + 1:]
            
            if len(before) % 2 == 0: # 前半後半可以各自形成
                for x in range(len(before) // 2):
                    v1 = before[x*2]
                    v2 = before[x*2 + 1]
                    average[x] = float((v1+v2) / 2)
                    difference[x] = float((v1-v2) / 2)
                for x, y in zip(range(int(m/2) + 1, length_next), range(len(after) // 2)):
                    v1 = after[y*2]
                    v2 = after[y*2 + 1]
                    average[x] = float((v1+v2) / 2)
                    difference[x] = float((v1-v2) / 2)
                # 中間那格必須和左右一起計算(共填一格)
                average[int((length_next-1)/2)] = (((before[-1]+middle)/2)+
                                                   ((middle+after[0])/2)) / 2
                difference[int((length_next-1)/2)] = (((before[-1]-middle)/2)+
                                                   ((middle-after[0])/2)) / 2
            
            else:
                del before[-1]
                del after[0]
                
                if before != []:
                    for x in range(int(length_next/2) - 1):
                        v1 = before[x*2]
                        v2 = before[x*2 + 1]
                        average[x] = float((v1+v2) / 2)
                        difference[x] = float((v1-v2) / 2)
                    for x, y in zip(range(int(length_next/2) + 1, length_next), range(len(after) // 2)):
                        v1 = after[y*2]
                        v2 = after[y*2 + 1]
                        average[x] = float((v1+v2) / 2)
                        difference[x] = float((v1-v2) / 2)
                # 填2個格子歐
                position1 = int(length_next/2) - 1
                position2 = position1 + 1
                average[position1] = (i[m-1] + middle) / 2
                average[position2] = (middle + i[m+1]) / 2
                difference[position1] = (i[m-1] - middle) / 2
                difference[position2] = (middle - i[m+1]) / 2
                
#         print(' ', average, difference)
        
        length = length_next
        i = average
        
        table.append([level, average, difference])
        level += 1
        
    return table

# for x in table:
#     print(table)

t = wavelet_coefficient_table(i)
print(t)

# 觀察table的level, difference的關係, choose some sensors
tables = {}
for s in stations[:1]:
    print(s)
    v = time_series(s, 'PM2.5')
    v = interpolate_linear1d(v)
    print(len(v))
    tables[s] = wavelet_coefficient_table(v)

    
def wavelet_coefficient_distribution(level, list_diff, stationid):
    # ex: {1: [x, x, x,... ]}
    '''
    output: a plot and distribution plot.
    Use this fuction many times, can obtain all coefficients for different levels and its frequency
    '''
#     plt.plot([1, 2, 3, 4], [1, 4, 9, 16], 'ro')
    
    xdata = range(len(list_diff))
    plt.plot(xdata, list_diff)
    plt.title(label=str(stationid)+": for the level" + str(level))
    plt.show()
    
    
    pass

for x in tables['aotizhongxin_aq'][1:]:
    print(x[0], x[1], x[2]) # level, average, difference
    pic = wavelet_coefficient_distribution(x[0], x[2], 'aotizhongxin_aq')

